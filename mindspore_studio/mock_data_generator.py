import os
import csv
import struct
import wave

# Configuration
FIRMWARE_DIR = "../firmware/main"
CSV_PATH = "datasets/env_anomaly_data.csv"
WAV_PATH = "datasets/audio/low_freq_drone/drone_400hz.wav"

def read_env_data():
    pressure = []
    voc = []
    
    if not os.path.exists(CSV_PATH):
        print(f"Warning: {CSV_PATH} not found. Using fallback data.")
        # Fallback linear data
        return [1010.0 - i*0.1 for i in range(100)], [50000 - i*400 for i in range(100)]
        
    with open(CSV_PATH, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            try:
                pressure.append(float(row['pressure_hpa']))
                voc.append(int(row['gas_resistance_ohm']))
            except (ValueError, KeyError):
                continue
                
    # Limit size for embedded (e.g., take a slice where the event happens)
    # We take the middle 100 samples where drops usually occur in our gen script
    mid = len(pressure) // 3
    return pressure[mid:mid+100], voc[mid:mid+100]

def read_audio_data():
    samples = []
    
    if not os.path.exists(WAV_PATH):
        print(f"Warning: {WAV_PATH} not found. Using fallback data.")
        return [0.0] * 128
        
    with wave.open(WAV_PATH, 'rb') as wf:
        n_frames = wf.getnframes()
        # Read only first 1024 frames to not consume too much memory in header
        raw_data = wf.readframes(min(n_frames, 1024))
        
        # Assume 16-bit PCM
        count = len(raw_data) // 2
        for i in range(count):
            val = struct.unpack_from('<h', raw_data, i*2)[0]
            # Normalize to -1.0 to 1.0
            samples.append(val / 32768.0)
            
    return samples

def main():
    # Ensure output directory exists
    if not os.path.exists(FIRMWARE_DIR):
        try:
            os.makedirs(FIRMWARE_DIR)
        except OSError:
            pass

    print("Reading environmental data...")
    pressure_data, voc_data = read_env_data()
    
    print("Reading audio data...")
    audio_data = read_audio_data()
    
    # Light data (Keep synthetic for now as we didn't generate a CSV for it in previous step, 
    # or we can just generate a simple pattern here without numpy)
    light_data = [4095 if i % 2 == 0 else 0 for i in range(128)]

    output_file = os.path.join(FIRMWARE_DIR, "mock_data.h")
    
    with open(output_file, "w") as f:
        f.write("#ifndef MOCK_DATA_H\n")
        f.write("#define MOCK_DATA_H\n\n")
        f.write("#include <stdint.h>\n\n")
        
        f.write("// generated by mock_data_generator.py\n")
        
        # Write Audio Data (Truncate to reasonable length for header file, e.g. 512 samples)
        audio_clip = audio_data[:512]
        f.write(f"const float MOCK_AUDIO_SAMPLE[] = {{ {', '.join(f'{x:.4f}' for x in audio_clip)} }};\n\n")
        
        # Write Light Data
        f.write(f"const uint16_t MOCK_LIGHT_FLICKER[] = {{ {', '.join(map(str, light_data))} }};\n\n")

        # Write Pressure Data
        f.write(f"const float MOCK_PRESSURE_DROP_SCENARIO[] = {{ {', '.join(f'{x:.2f}' for x in pressure_data)} }};\n\n")
        
        # Write VOC Data
        f.write(f"const uint32_t MOCK_VOC_SPIKE_SCENARIO[] = {{ {', '.join(map(str, voc_data))} }};\n")
        
        f.write("\n#endif // MOCK_DATA_H")

    print(f"Successfully generated {output_file}")
    print(f"  - Audio samples: {len(audio_clip)}")
    print(f"  - Pressure samples: {len(pressure_data)}")
    print(f"  - VOC samples: {len(voc_data)}")

if __name__ == "__main__":
    main()

